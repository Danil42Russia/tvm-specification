{
  "SENDRAWMSG": {
    "description": {
      "short": "",
      "long": "Sends a raw message contained in _Cell `c`_, which should contain a correctly serialized object `Message X`, with the only exception that the source address is allowed to have dummy value `addr_none` (to be automatically replaced with the current smart-contract address), and `ihr_fee`, `fwd_fee`, `created_lt` and `created_at` fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction).\n\nInteger parameter `x` contains the flags.\n\nCurrently `x == 0` is used for ordinary messages.\n\n`x=128` is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message).\n\n`x=64` is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount).\n\n`x'=x+1` means that the sender wants to pay transfer fees separately.\n\n`x'=x+2` means that any errors arising while processing this message during the action phase should be ignored.\n\nFinally, `x'=x+32` means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with `+128`.",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Cell"]
          },
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  },
  "RAWRESERVE": {
    "description": {
      "short": "",
      "long": "Creates an output action which would reserve exactly `x` nanograms (if `y == 0`), at most `x` nanograms (if `y == 2`), or all but `x` nanograms (if `y == 1` or `y == 3`), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying `x` nanograms (or `b-x` nanograms, where `b` is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit `+2` in `y` means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit `+8` in `y` means `x:=-x` before performing any further actions. Bit `+4` in `y` means that `x` is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently `x` must be a non-negative integer, and `y` must be in the range `0...15`.",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "y",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  },
  "RAWRESERVEX": {
    "description": {
      "short": "",
      "long": "Similar to `RAWRESERVE`, but also accepts a dictionary `D` (represented by a _Cell_ or _Null_) with extra currencies. In this way currencies other than Grams can be reserved.",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "D",
            "value_types": ["Cell", "Null"]
          },
          {
            "type": "simple",
            "name": "y",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  },
  "SETCODE": {
    "description": {
      "short": "",
      "long": "Creates an output action that would change this smart contract code to that given by _Cell_ `c`. Notice that this change will take effect only after the successful termination of the current run of the smart contract.",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Cell"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  },
  "SETLIBCODE": {
    "description": {
      "short": "",
      "long": "Creates an output action that would modify the collection of this smart contract libraries by adding or removing library with code given in _Cell_ `c`. If `x == 0`, the library is actually removed if it was previously present in the collection (if not, this action does nothing). If `x=1`, the library is added as a private library, and if `x=2`, the library is added as a public library (and becomes available to all smart contracts if the current smart contract resides in the masterchain); if the library was present in the collection before, its public/private status is changed according to `x`. Values of `x` other than `0...2` are invalid.",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Cell"]
          },
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  },
  "CHANGELIB": {
    "description": {
      "short": "",
      "long": "Creates an output action similarly to `SETLIBCODE`, but instead of the library code accepts its hash as an unsigned 256-bit integer `h`. If `x != 0` and the library with hash `h` is absent from the library collection of this smart contract, this output action will fail.",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "h",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  },
  "SENDMSG": {
    "description": {
      "short": "",
      "long": "Creates an output action and returns a fee for creating a message. Mode has the same effect as in the case of `SENDRAWMSG`. Additionally `+1024` means - do not create an action, only estimate fee. Other modes affect the fee calculation as follows: `+64` substitutes the entire balance of the incoming message as an outcoming value (slightly inaccurate, gas expenses that cannot be estimated before the computation is completed are not taken into account), `+128` substitutes the value of the entire balance of the contract before the start of the computation phase (slightly inaccurate, since gas expenses that cannot be estimated before the completion of the computation phase are not taken into account).",
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Cell"]
          },
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "fee",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 5
          }
        ]
      }
    }
  }
}
