{
  "RETURNVARARGS": {
    "description": {
      "short": "",
      "long": "Leaves only the top `p` values in the current stack, where `p` is taken from the stack. Unlike `RETURNARGS` which takes the number of values to keep from the instruction itself, this instruction takes this number from the stack. All the unused bottom values are not discarded, but saved into continuation `c0` in the same way as `SETCONTARGS` does.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "p",
            "value_types": ["Int"],
            "range": {
              "min": 0,
              "max": 255
            }
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    }
  },
  "SETCONTVARARGS": {
    "description": {
      "short": "",
      "long": "Pushes values onto the stack of a continuation and optionally sets the number of missing arguments. Unlike `SETCONTARGS` which takes the number of values to push and the number of missing arguments from the instruction itself, this instruction takes `r` and `n` from the stack. It pushes `r` values from the current stack onto the stack of continuation `c`, and for `n` not equal to -1, sets `c.nargs` to the final size of the stack of `c` plus `n`, effectively creating a closure with `n` missing arguments.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "array",
            "name": "args",
            "length_var": "r",
            "array_entry": [
              {
                "type": "simple",
                "name": "x"
              }
            ]
          },
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "r",
            "value_types": ["Int"],
            "range": {
              "min": 0,
              "max": 255
            }
          },
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"],
            "range": {
              "min": -1,
              "max": 255
            }
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "SETNUMVARARGS": {
    "description": {
      "short": "",
      "long": "Sets the number of arguments expected by continuation `c`. If `n=-1`, this operation does nothing (`c'=c`). Otherwise, it sets `c.nargs` to `n`, where `n` is taken from the stack. Unlike `SETNUMARGS` which takes the number of expected arguments from the instruction itself, this instruction takes this number from the stack.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "n",
            "range": {
              "min": -1,
              "max": 255
            },
            "value_types": ["Int"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "BLESS": {
    "description": {
      "short": "",
      "long": "Transforms a _Slice_ `s` into a simple ordinary continuation `c`, with `c.code=s` and an empty stack and savelist.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "s",
            "value_types": ["Slice"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "BLESSVARARGS": {
    "description": {
      "short": "",
      "long": "Transforms a _Slice_ into a simple ordinary continuation and sets its arguments from the stack.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["ROT", "BLESS", "ROTREV", "SETCONTVARARGS"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "array",
            "name": "args",
            "length_var": "r",
            "array_entry": [
              {
                "type": "simple",
                "name": "x"
              }
            ]
          },
          {
            "type": "simple",
            "name": "s",
            "value_types": ["Slice"]
          },
          {
            "type": "simple",
            "name": "r",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "PUSHCTRX": {
    "description": {
      "short": "",
      "long": "Pushes the current value of control register `c(i)` onto the stack, where `i` is taken from the stack. Unlike `c(i) PUSHCTR` which takes the register index from the instruction itself, this instruction takes this index from the stack. If the control register is not supported in the current codepage, or if it does not have a value, an exception is triggered.\nNotice that this primitive is one of the few \"exotic\" primitives, which are not polymorphic like stack manipulation primitives, and at the same time do not have well-defined types of parameters and return values, because the type of `x` depends on `i`.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "i",
            "value_types": ["Int"],
            "range": {
              "min": 0,
              "max": 255
            }
          }
        ],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          }
        ]
      }
    }
  },
  "POPCTRX": {
    "description": {
      "short": "",
      "long": "Pops a value `x` from the stack and stores it into control register `c(i)`, where `i` is taken from the stack. Unlike `c(i) POPCTR` which takes the register index from the instruction itself, this instruction takes this index from the stack. If the control register is not supported in the current codepage, or if it only accepts values of a specific type and `x` is not of that type, an exception is triggered.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          },
          {
            "type": "simple",
            "name": "i",
            "value_types": ["Int"],
            "range": {
              "min": 0,
              "max": 255
            }
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          }
        ]
      }
    }
  },
  "SETCONTCTRX": {
    "description": {
      "short": "",
      "long": "Stores value `x` into the savelist of continuation `c` as `c(i)`, and returns the resulting continuation `c'`, where `i` is taken from the stack. Unlike `c(i) SETCONTCTR` which takes the register index from the instruction itself, this instruction takes this index from the stack. Almost all operations with continuations may be expressed in terms of this primitive, along with `POPCTRX` and `PUSHCTRX`.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          },
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "i",
            "value_types": ["Int"],
            "range": {
              "min": 0,
              "max": 255
            }
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "SETCONTCTRMANYX": {
    "description": {
      "short": "Sets multiple control registers in a continuation by a `mask`.",
      "long": "Takes a `mask` that describes which control registers of the current continuation should be copied and set in continuation `c`. This is a more efficient version of multiple `SETCONTCTRX` calls.",
      "tags": ["continuation", "control"],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "mask",
            "value_types": ["Int"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c'",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      }
    }
  },
  "BOOLAND": {
    "description": {
      "short": "",
      "long": "Computes the composition `compose0(c, c')`, which has the meaning of \"perform `c`, and, if successful, perform `c'`\" (if `c` is a boolean circuit) or simply \"perform `c`, then `c'`\".",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SWAP", "c0 SETCONT"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "c'",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c3",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      }
    }
  },
  "BOOLOR": {
    "description": {
      "short": "",
      "long": "Computes the alternative composition `compose1(c, c')`, which has the meaning of \"perform `c`, and, if not successful, perform `c'`\" (if `c` is a boolean circuit).",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SWAP", "c1 SETCONT"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "c'",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c3",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      }
    }
  },
  "COMPOSBOTH": {
    "description": {
      "short": "",
      "long": "Computes composition `compose1(compose0(c, c'), c')`, which has the meaning of \"compute boolean circuit `c`, then compute `c'`, regardless of the result of `c`\".",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c3",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "ATEXIT": {
    "description": {
      "short": "",
      "long": "Sets `c0` to `compose0(c, c0)`. In other words, `c` will be executed before exiting current continuation.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      }
    }
  },
  "ATEXITALT": {
    "description": {
      "short": "",
      "long": "Sets `c1` to `compose1(c, c1)`. In other words, `c` will be executed before exiting current continuation by its alternative return path.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "SETEXITALT": {
    "description": {
      "short": "",
      "long": "Sets `c1` to `compose1(compose0(c, c0), c1)`,\nIn this way, a subsequent `RETALT` will first execute `c`, then transfer control to the original `c0`. This can be used, for instance, to exit from nested loops.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "THENRET": {
    "description": {
      "short": "",
      "long": "Computes `compose0(c, c0)`.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "THENRETALT": {
    "description": {
      "short": "",
      "long": "Computes `compose0(c, c1)`",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "INVERT": {
    "description": {
      "short": "",
      "long": "Interchanges `c0` and `c1`.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "BOOLEVAL": {
    "description": {
      "short": "",
      "long": "Performs `cc := compose1(compose0(c, compose0(-1 PUSHINT, cc)), compose0(0 PUSHINT, cc))`. If `c` represents a boolean circuit, the net effect is to evaluate it and push either `-1` or `0` onto the stack before continuing.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "result",
            "value_types": ["Bool"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "special",
              "name": "pushint",
              "args": {
                "next": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                },
                "value": -1
              }
            },
            "c1": {
              "type": "special",
              "name": "pushint",
              "args": {
                "next": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                },
                "value": 0
              }
            }
          }
        }
      ]
    }
  },
  "SAMEALT": {
    "description": {
      "short": "",
      "long": "Sets `c1` to `c0`.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["c0 PUSHCTR", "c1 POPCTR"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "SAMEALTSAVE": {
    "description": {
      "short": "",
      "long": "Sets `c1` to `c0`, but first saves the old value of `c1` into the savelist of `c0`.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["c1 SAVE", "SAMEALT"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "SETCONTCTRMANY": {
    "description": {
      "short": "Sets multiple control registers in a continuation by a `mask`.",
      "long": "Takes a `mask` that describes which control registers of the current continuation should be copied and set in continuation `c`. Returns the modified continuation. This is similar to `SETCONTCTRMANYX` but uses fixed `mask` specified in the instruction.",
      "tags": ["continuation", "control"],
      "operands": ["mask"]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c'",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      }
    }
  },
  "RETURNARGS": {
    "description": {
      "short": "",
      "long": "Leaves only the top `p` values in the current stack (somewhat similarly to `ONLYTOPX`), with all the unused bottom values not discarded, but saved into continuation `c0` in the same way as `SETCONTARGS` does.",
      "tags": [],
      "operands": ["p"]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    }
  },
  "SETCONTARGS": {
    "description": {
      "short": "",
      "long": "Pushes `r` values `x_1...x_r` into the stack of (a copy of) the continuation `c`, starting with `x_1`. When `n` is 15 (-1 in Fift notation), does nothing with `c.nargs`. For other values of `n`, sets `c.nargs` to the final size of the stack of `c'` plus `n`. In other words, transforms `c` into a _closure_ or a _partially applied function_, with `n` arguments missing.",
      "tags": [],
      "operands": ["r", "n"]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "array",
            "name": "args",
            "length_var": "r",
            "array_entry": [
              {
                "type": "simple",
                "name": "x"
              }
            ]
          },
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      }
    }
  },
  "BLESSARGS": {
    "description": {
      "short": "Transforms a _Slice_ into a simple ordinary continuation and sets `r` arguments and `n` missing arguments.",
      "long": "The value of `n` is represented inside the instruction by the 4-bit integer `n mod 16`.",
      "tags": [],
      "operands": ["r", "n"],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["BLESS", "[r] [n] SETCONTARGS"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "array",
            "name": "args",
            "length_var": "r",
            "array_entry": [
              {
                "type": "simple",
                "name": "x"
              }
            ]
          },
          {
            "type": "simple",
            "name": "s",
            "value_types": ["Slice"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "SETCONTCTR": {
    "description": {
      "short": "",
      "long": "Stores `x` into the savelist of continuation `c` as `c(i)`, and returns the resulting continuation `c'`. Almost all operations with continuations may be expressed in terms of `SETCONTCTR`, `POPCTR`, and `PUSHCTR`.",
      "tags": [],
      "operands": ["i"]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          },
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c2",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "SETRETCTR": {
    "description": {
      "short": "",
      "long": "Stores the value from control register `c(i)` into the savelist of continuation `c0`.",
      "tags": [],
      "operands": ["i"],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["c0 PUSHCTR", "c(i) SETCONTCTR", "c0 POPCTR"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      }
    }
  },
  "SETALTCTR": {
    "description": {
      "short": "",
      "long": "Stores the value from control register `c(i)` into the savelist of continuation `c1`.",
      "tags": [],
      "operands": ["i"],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["c1 PUSHCTR", "c(i) SETCONTCTR", "c1 POPCTR"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "POPSAVE": {
    "description": {
      "short": "",
      "long": "Pops a value from the stack and stores it into control register `c(i)`, but also saves the old value of `c(i)` into continuation `c0`.",
      "tags": [],
      "operands": ["i"],
      "other_implementations": [
        {
          "exact": false,
          "instructions": ["c(i) SAVECTR", "c(i) POPCTR"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          }
        ],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          },
          {
            "type": "constant",
            "index": 0
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      }
    }
  },
  "SAVECTR": {
    "description": {
      "short": "",
      "long": "Saves the current value of `c(i)` into the savelist of continuation `c0`. If an entry for `c(i)` is already present in the savelist of `c0`, nothing is done.",
      "tags": [],
      "operands": ["i"],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["c(i) PUSHCTR", "c(i) SETRETCTR"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          },
          {
            "type": "constant",
            "index": 0
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      }
    }
  },
  "SAVEALTCTR": {
    "description": {
      "short": "",
      "long": "Similar to `c(i) SAVE`, but saves the current value of `c(i)` into the savelist of `c1`, not `c0`.",
      "tags": [],
      "operands": ["i"]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "SAVEBOTHCTR": {
    "description": {
      "short": "",
      "long": "Saves the current value of `c(i)` into the savelist of both `c0` and `c1`.",
      "tags": [],
      "operands": ["i"],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["c(i) SAVE", "c(i) SAVEALT"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          },
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 0
          },
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "PUSHCTR": {
    "description": {
      "short": "",
      "long": "Pushes the current value of control register `c(i)`. If the control register is not supported in the current codepage, or if it does not have a value, throws an exception.",
      "tags": [],
      "operands": ["i"]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          }
        ]
      }
    }
  },
  "POPCTR": {
    "description": {
      "short": "",
      "long": "Pops a value `x` from the stack and stores it into control register `c(i)`, if supported in the current codepage. Notice that if a control register accepts only values of a specific type, a type-checking exception may occur.",
      "tags": [],
      "operands": ["i"],
      "exit_codes": [
        {
          "errno": "7",
          "condition": "Invalid value type for control register."
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x"
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "variable",
            "var_name": "i"
          }
        ]
      }
    }
  }
}
