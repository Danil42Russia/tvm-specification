{
  "IFRET": {
    "description": {
      "short": "If `cond` is non-zero, ends the current continuation and returns to `c0`.",
      "long": "If condition is met, performs `RET` which ends the current continuation and returns to continuation in `c0`. If `c0` holds the initial `quit` continuation (that is, the current execution is in the root continuation), the program exits with code 0.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "docs_links": [
        {
          "name": "c0 register and normal exit point",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/#normal-exit-point-c0"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "register",
          "index": 0
        }
      ]
    }
  },
  "IFNOTRET": {
    "description": {
      "short": "If `cond` is zero, ends the current continuation and returns to `c0`.",
      "long": "If condition is met, performs `RET` which ends the current continuation and returns to continuation in `c0`. If `c0` holds the initial `quit` continuation (that is, the current execution is in the root continuation), the program exits with code 0.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "docs_links": [
        {
          "name": "c0 register and normal exit point",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/#normal-exit-point-c0"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 0
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "register",
          "index": 0
        }
      ]
    }
  },
  "IF": {
    "description": {
      "short": "If `cond` is non-zero, executes `body`, otherwise does nothing.",
      "long": "If condition is met, performs `EXECUTE` on `body` continuation. After the body is executed, execution will return to the next instruction after the `IF`.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 -1",
              "comment": "Condition value (non-zero means true)"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 10\n  PUSHINT_4 20\n  ADD\n}",
              "comment": "Continuation body that adds 10 and 20"
            },
            {
              "instruction": "IF",
              "comment": "Execute the continuation if condition is true"
            }
          ],
          "stack": {
            "input": ["-1", "Continuation"],
            "output": ["30"]
          }
        },
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 0",
              "comment": "Condition value (zero means false)"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 10\n  PUSHINT_4 20\n  ADD\n}",
              "comment": "Continuation body that adds 10 and 20"
            },
            {
              "instruction": "IF",
              "comment": "Execute the continuation if condition is true"
            }
          ],
          "stack": {
            "input": ["0", "Continuation"],
            "output": []
          }
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFNOT": {
    "description": {
      "short": "If `cond` is zero, executes `body`, otherwise does nothing.",
      "long": "If condition is met, performs `EXECUTE` on `body` continuation. After the body is executed, execution will return to the next instruction after the `IFNOT`.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 0",
              "comment": "Condition value (zero means false)"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 10\n  PUSHINT_4 20\n  ADD\n}",
              "comment": "Continuation body that adds 10 and 20"
            },
            {
              "instruction": "IFNOT",
              "comment": "Execute the continuation if condition is false"
            }
          ],
          "stack": {
            "input": ["0", "Continuation"],
            "output": ["30"]
          }
        },
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 -1",
              "comment": "Condition value (non-zero means true)"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 10\n  PUSHINT_4 20\n  ADD\n}",
              "comment": "Continuation body that adds 10 and 20"
            },
            {
              "instruction": "IFNOT",
              "comment": "Execute the continuation if condition is false"
            }
          ],
          "stack": {
            "input": ["-1", "Continuation"],
            "output": []
          }
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFJMP": {
    "description": {
      "short": "If `cond` is non-zero, jumps to `body`, otherwise does nothing.",
      "long": "If condition is met, performs `JMPX` on `body` continuation. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFJMP`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0.",
      "tags": ["control_flow"],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT -1"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 1\n  PUSHINT_4 2\n  ADD\n  // implicit exit from the continuation\n  // and since grand continuation is default `quit`\n  // the program will exit with code 0\n}",
              "is_main": true
            },
            {
              "instruction": "IFJMP",
              "comment": "Transfers control to the continuation",
              "is_main": true
            },
            {
              "instruction": "PUSHINT_LONG 999",
              "comment": "This will never be executed"
            }
          ],
          "stack": {
            "input": ["Continuation", "-1"],
            "output": []
          }
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFNOTJMP": {
    "description": {
      "short": "If `cond` is zero, jumps to `body`, otherwise does nothing.",
      "long": "If condition is met, performs `JMPX` on `body` continuation. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFNOTJMP`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0.",
      "tags": ["control_flow"],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT 0"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 1\n  PUSHINT_4 2\n  ADD\n  // implicit exit from the continuation\n  // and since grand continuation is default `quit`\n  // the program will exit with code 0\n}",
              "is_main": true
            },
            {
              "instruction": "IFNOTJMP",
              "comment": "Transfers control to the continuation",
              "is_main": true
            },
            {
              "instruction": "PUSHINT_LONG 999",
              "comment": "This will never be executed"
            }
          ],
          "stack": {
            "input": ["Continuation", "0"],
            "output": []
          }
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFELSE": {
    "description": {
      "short": "If `cond` is non-zero, executes `body`, otherwise executes `else`.",
      "long": "If condition is met, performs `EXECUTE` on `body` continuation, otherwise performs `EXECUTE` on `else` continuation. After the either body is executed, execution will return to the next instruction after the `IFELSE`.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["CONDSELCHK", "EXECUTE"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "else",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        },
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "CONDSEL": {
    "description": {
      "short": "If integer `f` is non-zero, returns `x`, otherwise returns `y`.",
      "long": "No type checks are performed on `x` and `y`, so this can be thought of as a conditional stack operation.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": false,
          "instructions": ["ROT", "ISZERO", "INC", "ROLLX", "NIP"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "x"
          },
          {
            "type": "simple",
            "name": "y"
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "result"
          }
        ]
      }
    }
  },
  "CONDSELCHK": {
    "description": {
      "short": "If integer `f` is non-zero, returns `x`, otherwise returns `y`.",
      "long": "Checks whether `x` and `y` have the same type, unlike `CONDSEL`.",
      "tags": [],
      "exit_codes": [
        {
          "errno": "7",
          "condition": "If `x` and `y` have different types."
        }
      ],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "x"
          },
          {
            "type": "simple",
            "name": "y"
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "result"
          }
        ]
      }
    }
  },
  "IFRETALT": {
    "description": {
      "short": "If `cond` is non-zero, ends the current continuation and returns to `c1`.",
      "long": "If condition is met, performs `RETALT` which ends the current continuation and returns to continuation in `c1`. If `c1` holds the initial `quit` continuation (that is, the current execution is in the root continuation), the program exits with code 0.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "docs_links": [
        {
          "name": "c1 register and alternative exit point",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/#alternative-exit-point-c1"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "register",
          "index": 1
        }
      ]
    }
  },
  "IFNOTRETALT": {
    "description": {
      "short": "If `cond` is zero, ends the current continuation and returns to `c1`.",
      "long": "If condition is met, performs `RETALT` which ends the current continuation and returns to continuation in `c1`. If `c1` holds the initial `quit` continuation (that is, the current execution is in the root continuation), the program exits with code 0.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "docs_links": [
        {
          "name": "c1 register and alternative exit point",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/#alternative-exit-point-c1"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "register",
          "index": 1
        }
      ]
    }
  },
  "IFBITJMP": {
    "description": {
      "short": "If `i`-th bit is set in integer `x`, jumps to `body`, otherwise does nothing.",
      "long": "If condition is met, performs `JMPX` on `body` continuation. Value `x` remains on the stack and available in `body` continuation. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFBITJMP`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0.",
      "tags": [],
      "operands": ["i"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `x` is a `NaN`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT 0b001000"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 1\n  ADD // sum up 4 and 1\n  // implicit exit from the continuation\n  // and since grand continuation is default `quit`\n  // the program will exit with code 0\n}",
              "is_main": true
            },
            {
              "instruction": "IFBITJMP 3",
              "comment": "Check 4th bit of 0b001000",
              "is_main": true
            },
            {
              "instruction": "PUSHINT_LONG 999",
              "comment": "This will never be executed"
            }
          ],
          "stack": {
            "input": ["Continuation", "8"],
            "output": []
          }
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFNBITJMP": {
    "description": {
      "short": "If `i`-th bit is NOT set in integer `x`, jumps to `body`, otherwise does nothing.",
      "long": "If condition is met, performs `JMPX` on `body` continuation. Value `x` remains on the stack and available in `body` continuation. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFNBITJMP`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0.",
      "tags": [],
      "operands": ["i"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `x` is a `NaN`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT 0b001000"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 1\n  ADD // sum up 4 and 1\n  // implicit exit from the continuation\n  // and since grand continuation is default `quit`\n  // the program will exit with code 0\n}",
              "is_main": true
            },
            {
              "instruction": "IFNBITJMP 2",
              "comment": "Check 3rd bit of 0b001000",
              "is_main": true
            },
            {
              "instruction": "PUSHINT_LONG 999",
              "comment": "This will never be executed"
            }
          ],
          "stack": {
            "input": ["Continuation", "8"],
            "output": []
          }
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFREF": {
    "description": {
      "short": "If `cond` is non-zero, executes `body` stored in code cell reference, otherwise does nothing.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally transfers execution to it. After the body is executed, execution will return to the next instruction after the `IFREF`. When condition is not met, reference is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": false,
          "instructions": ["PUSHREFCONT", "IF"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFNOTREF": {
    "description": {
      "short": "If `cond` is zero, executes `body` stored in code cell reference, otherwise does nothing.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally transfers execution to it. After the body is executed, execution will return to the next instruction after the `IFNOTREF`. When condition is not met, reference is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["PUSHREFCONT", "IFNOT"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFJMPREF": {
    "description": {
      "short": "If `cond` is non-zero, jumps to `body` stored in code cell reference, otherwise does nothing.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally jumps to it. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFJMPREF`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0. When condition is not met, reference is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["PUSHREFCONT", "IFJMP"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFNOTJMPREF": {
    "description": {
      "short": "If `cond` is zero, jumps to `body` stored in code cell reference, otherwise does nothing.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally jumps to it. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFNOTJMPREF`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0. When condition is not met, reference is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["PUSHREFCONT", "IFNOTJMP"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFREFELSE": {
    "description": {
      "short": "If `cond` is non-zero, executes the continuation stored in cell reference `body`, otherwise executes `else` continuation from the stack.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally transfers execution to it. Otherwise, performs `EXECUTE` on `else` continuation. After either body is executed, execution will return to the next instruction after the `IFREFELSE`. When condition is not met, reference for `body` is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": false,
          "instructions": ["PUSHREFCONT", "SWAP", "IFELSE"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "else",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        },
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFELSEREF": {
    "description": {
      "short": "If `cond` is non-zero, executes `body` from the stack, otherwise executes the continuation stored in cell reference `else`.",
      "long": "If condition is met, performs `EXECUTE` on `body` continuation. Otherwise, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally transfers execution to it. After either body is executed, execution will return to the next instruction after the `IFELSEREF`. When condition is met, reference for `else` is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["else"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["PUSHREFCONT", "IFELSE"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        },
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFREFELSEREF": {
    "description": {
      "short": "If `cond` is non-zero, executes the continuation stored in cell reference `body`, otherwise executes the continuation stored in cell reference `else`.",
      "long": "If condition is met, load first reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally transfers execution to it. Otherwise, load second reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally transfers execution to it. After either body is executed, execution will return to the next instruction after the `IFREFELSEREF`.",
      "tags": [],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `cond` is a `NaN`."
        }
      ],
      "operands": ["body", "else"],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["PUSHREFCONT", "PUSHREFCONT", "IFELSE"]
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c1",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        },
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "IFBITJMPREF": {
    "description": {
      "short": "If `i`-th bit is set in integer `x`, jumps to `body` stored in code cell reference, otherwise does nothing.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally jumps to it. Value `x` remains on the stack and available in `body` continuation. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFBITJMPREF`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0. When condition is not met, reference is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["i", "body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `x` is a `NaN`."
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  },
  "IFNBITJMPREF": {
    "description": {
      "short": "If `i`-th bit is NOT set in integer `x`, jumps to `body` stored in code cell reference, otherwise does nothing.",
      "long": "If condition is met, load reference from the current code cell, transforms it to a _Slice_ and then to an ordinary _Continuation_ and finally jumps to it. Value `x` remains on the stack and available in `body` continuation. The remainder of the current continuation is discarded which means that after `body` completes, control will not return to instruction immediately following the `IFNBITJMPREF`. Instead, it will return to the instruction immediately following the instruction that started current continuation. If this continuation is default `quit`, the program will exit with code 0. When condition is not met, reference is not loaded, so instruction does not consume extra gas for cell loading.",
      "tags": [],
      "operands": ["i", "body"],
      "exit_codes": [
        {
          "errno": "4",
          "condition": "If `x` is a `NaN`."
        }
      ],
      "docs_links": [
        {
          "name": "JMP vs. EXECUTE",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/manual-handling-and-jmp-vs-execute/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ]
      },
      "outputs": {
        "stack": [
          {
            "type": "simple",
            "name": "x",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c"
        }
      ]
    }
  }
}
