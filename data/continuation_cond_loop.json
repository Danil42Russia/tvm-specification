{
  "REPEAT": {
    "description": {
      "short": "Executes continuation `body` `n`-times, if integer `n` is non-negative.",
      "long": "`RET` inside the code of `body` works as a `continue`, not as a `break`. To `break` from the loop, use either alternative loop `REPEATBRK` + `RETALT` or `RETALT`, along with a `SETEXITALT` before the loop.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "5",
          "condition": "If `n >= 2^31` or `n < -2^31`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 0",
              "comment": "Initialize sum"
            },
            {
              "instruction": "PUSHINT_4 5",
              "comment": "Number of iterations"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 10\n  ADD\n}",
              "comment": "Body: add 10 to the sum in each iteration"
            },
            {
              "instruction": "REPEAT",
              "comment": "Execute the body 5 times"
            }
          ],
          "stack": {
            "input": ["0", "5", "Body"],
            "output": ["50"]
          }
        }
      ],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "variable",
              "var_name": "c"
            },
            "after": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "REPEATEND": {
    "description": {
      "short": "",
      "long": "Executes the current continuation `cс` `n` times, if integer `n` is non-negative. This is like `REPEAT` but instead of executing a separate continuation `body`, it repeatedly executes the current continuation. If `n >= 2^31` or `n < -2^31`, generates a range check exception.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "cc"
            },
            "after": {
              "type": "register",
              "index": 0
            }
          }
        }
      ]
    }
  },
  "UNTIL": {
    "description": {
      "short": "Executes continuation `body`, then pops an integer `cond` from the resulting stack. If `cond` is **zero**, performs another iteration of this loop, otherwise ends the loop.",
      "long": "The actual implementation of this primitive involves an extraordinary continuation `ec_until` with its arguments set to the `body` of the loop and the original current continuation `cс`. This extraordinary continuation is then saved into the savelist of `body` as `body.c0` and the modified `body` is then executed. The other loop primitives are implemented similarly with the aid of suitable extraordinary continuations.",
      "tags": [],
      "operands": [],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_8 100"
            },
            {
              "instruction": "PUSHCONT {\n    DEC\n    DUP"
            },
            {
              "instruction": "    EQINT 10",
              "comment": "Check if counter is ten,"
            },
            {
              "instruction": "            ",
              "comment": "if true, exit the loop"
            },
            {
              "instruction": "}"
            },
            {
              "instruction": "UNTIL",
              "comment": "Starts the loop",
              "is_main": true
            }
          ],
          "stack": {
            "input": ["Continuation", "100"],
            "output": ["10"]
          }
        }
      ],
      "docs_links": [
        {
          "name": "Save lists",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/basics-register-c0-cc-savelist-if-instruction/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "variable",
                  "var_name": "c"
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "UNTILEND": {
    "description": {
      "short": "",
      "long": "Executes the current continuation `cс`, then pops an integer `x` from the resulting stack. If `x` is zero, performs another iteration of this loop. Unlike `UNTIL` which executes a separate continuation as the loop body, this instruction uses the current continuation itself as the loop body. When the loop exit condition is satisfied (when `x` is non-zero), performs a `RET`.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "cc",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "cc"
                },
                "after": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "WHILE": {
    "description": {
      "short": "Executes continuation `cond`, then pops an integer `cond` from the resulting stack. If `cond` is **non-zero**, executes `body`, and then begins a new iteration, otherwise ends the loop.",
      "long": "The actual implementation of this primitive involves an extraordinary continuation `ec_while`.",
      "tags": [],
      "operands": [],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 0",
              "comment": "Initialize counter"
            },
            {
              "instruction": "PUSHCONT {\n  DUP\n  PUSHINT_4 3\n  LESS\n}",
              "comment": "Condition: check if counter < 3"
            },
            {
              "instruction": "PUSHCONT {\n  INC\n}",
              "comment": "Body: increment counter"
            },
            {
              "instruction": "WHILE",
              "comment": "Execute loop while condition is true"
            }
          ],
          "stack": {
            "input": ["0", "Condition", "Body"],
            "output": ["3"]
          }
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "special",
              "name": "while",
              "args": {
                "cond": {
                  "type": "variable",
                  "var_name": "c2"
                },
                "body": {
                  "type": "variable",
                  "var_name": "c"
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "WHILEEND": {
    "description": {
      "short": "",
      "long": "Executes continuation `c'` and pops an integer `x` from the resulting stack. If `x` is zero, exits the loop and transfers control to the original continuation. If `x` is non-zero, executes the current continuation `cс` as the loop body, and then begins a new iteration. Unlike `WHILE` which uses a separate continuation as the loop body, this instruction uses the current continuation itself as the loop body.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "special",
              "name": "while",
              "args": {
                "cond": {
                  "type": "variable",
                  "var_name": "c2"
                },
                "body": {
                  "type": "cc"
                },
                "after": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "AGAIN": {
    "description": {
      "short": "Executes continuation `body` infinitely many times.",
      "long": "Unlike `REPEAT` which executes a continuation a specified number of times, this instruction creates an infinite loop. `RET` inside `body` code starts a new iteration of an infinite loop, rather than breaks from the loop. `AGAIN` loop can be exited only by an exception, `RETALT` with a `SETEXITALT` before the loop, or an explicit `JMPX`. Another way is to use `AGAINBRK`, which also sets `c1` to `cc`, and `RETALT` in the body, which will transfer control to the original `cc` and exit the loop.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "again",
          "args": {
            "body": {
              "type": "variable",
              "var_name": "c"
            }
          }
        }
      ]
    }
  },
  "AGAINEND": {
    "description": {
      "short": "Takes a remainder of the current continuation and executes it infinitely many times.",
      "long": "Unlike `AGAIN` which executes a separate continuation in an infinite loop, this instruction uses the current continuation itself as the loop body. `RET` inside `body` code starts a new iteration of an infinite loop, rather than breaks from the loop. `AGAINEND` loop can be exited only by an exception, `RETALT` with a `SETEXITALT` before the loop, or an explicit `JMPX`. Another way is to use `AGAINENDBRK`, which also sets `c1` to `cc`, and `RETALT` in the body, which will transfer control to the original `cc` and exit the loop.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "again",
          "args": {
            "body": {
              "type": "cc"
            }
          }
        }
      ]
    }
  },
  "REPEATBRK": {
    "description": {
      "short": "",
      "long": "Executes continuation `body` `n` times, if integer `n` is non-negative, just like `REPEAT`. Additionally, it sets `c1` to the original `c` after saving the old value of `c1` into the savelist of the original `c`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before all iterations are completed.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "variable",
              "var_name": "c",
              "save": {
                "c1": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                }
              }
            },
            "after": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                },
                "c1": {
                  "type": "register",
                  "index": 1
                }
              }
            }
          }
        }
      ]
    }
  },
  "REPEATENDBRK": {
    "description": {
      "short": "",
      "long": "Executes the current continuation `cс` `n` times, if integer `n` is non-negative, just like `REPEATEND`. Additionally, it sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before all iterations are completed.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "REPEATEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "cc",
              "save": {
                "c1": {
                  "type": "register",
                  "index": 0
                }
              }
            },
            "after": {
              "type": "register",
              "index": 0
            }
          }
        }
      ]
    }
  },
  "UNTILBRK": {
    "description": {
      "short": "",
      "long": "Executes continuation `c`, then pops an integer `x` from the resulting stack. If `x` is zero, performs another iteration of this loop, just like `UNTIL`. Additionally, it sets `c1` to the original continuation after saving the old value of `c1` into the savelist of the original continuation. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the exit condition is met.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "variable",
                  "var_name": "c",
                  "save": {
                    "c1": {
                      "type": "cc",
                      "save": {
                        "c0": {
                          "type": "register",
                          "index": 0
                        },
                        "c1": {
                          "type": "register",
                          "index": 1
                        }
                      }
                    }
                  }
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                }
              }
            },
            "c1": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                },
                "c1": {
                  "type": "register",
                  "index": 1
                }
              }
            }
          }
        }
      ]
    }
  },
  "UNTILENDBRK": {
    "description": {
      "short": "",
      "long": "Executes the current continuation `cс`, then pops an integer `x` from the resulting stack. If `x` is zero, performs another iteration of this loop, just like `UNTILEND`. Additionally, it sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the exit condition is met.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "UNTILEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "cc",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "cc",
                  "save": {
                    "c1": {
                      "type": "register",
                      "index": 0
                    }
                  }
                },
                "after": {
                  "type": "register",
                  "index": 0
                }
              }
            },
            "c1": {
              "type": "register",
              "index": 0
            }
          }
        }
      ]
    }
  },
  "WHILEBRK": {
    "description": {
      "short": "",
      "long": "Executes continuation `c'` and pops an integer `x` from the resulting stack. If `x` is zero, exits the loop and transfers control to the original continuation. If `x` is non-zero, executes continuation `c`, and then begins a new iteration, just like `WHILE`. Additionally, it sets `c1` to the original continuation after saving the old value of `c1` into the savelist of the original continuation. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the condition becomes false.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c2",
          "save": {
            "c0": {
              "type": "special",
              "name": "while",
              "args": {
                "cond": {
                  "type": "variable",
                  "var_name": "c2"
                },
                "body": {
                  "type": "variable",
                  "var_name": "c"
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "WHILEENDBRK": {
    "description": {
      "short": "",
      "long": "Executes continuation `c'` and pops an integer `x` from the resulting stack. If `x` is zero, exits the loop and transfers control to the original continuation. If `x` is non-zero, executes the current continuation `cс` as the loop body, and then begins a new iteration, just like `WHILEEND`. Additionally, it sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the condition becomes false.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "WHILEEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "c",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "AGAINBRK": {
    "description": {
      "short": "Store current continuation in `c1` of `body` and executes continuation `body` infinitely many times.",
      "long": "This instruction sets `c1` to the original continuation after saving the old value of `c1` into the savelist of the original continuation. This modification allows `RETALT` to be used to break out of the infinite loop, providing a way to exit the loop that would otherwise continue indefinitely.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    }
  },
  "AGAINENDBRK": {
    "description": {
      "short": "",
      "long": "Executes the current continuation `cс` infinitely many times, just like `AGAINEND`. Additionally, it sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the infinite loop, providing a way to exit the loop that would otherwise continue indefinitely.",
      "tags": [],
      "operands": [],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "AGAINEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    }
  }
}
