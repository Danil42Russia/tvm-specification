{
  "REPEAT": {
    "description": {
      "short": "Executes continuation `body` `n`-times, if integer `n` is non-negative.",
      "long": "`RET` inside the code of `body` works as a `continue`, not as a `break`. To `break` from the loop, use either alternative loop `REPEATBRK` + `RETALT` or `RETALT`, along with a `SETEXITALT` before the loop.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "5",
          "condition": "If `n >= 2^31` or `n < -2^31`."
        }
      ],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 0",
              "comment": "Initialize sum"
            },
            {
              "instruction": "PUSHINT_4 5",
              "comment": "Number of iterations"
            },
            {
              "instruction": "PUSHCONT {\n  PUSHINT_4 10\n  ADD\n}",
              "comment": "Body: add 10 to the sum in each iteration"
            },
            {
              "instruction": "REPEAT",
              "comment": "Execute the body 5 times"
            }
          ],
          "stack": {
            "input": ["0", "5", "Body"],
            "output": ["50"]
          }
        }
      ],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "variable",
              "var_name": "c"
            },
            "after": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "REPEATEND": {
    "description": {
      "short": "Takes a remainder of the current continuation and executes it `n`-times, if integer `n` is non-negative.",
      "long": "Unlike `REPEAT` which executes a separate continuation `body` as the loop body, this instruction uses the current continuation itself as the loop body.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "5",
          "condition": "If `n >= 2^31` or `n < -2^31`."
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "cc"
            },
            "after": {
              "type": "register",
              "index": 0
            }
          }
        }
      ]
    }
  },
  "UNTIL": {
    "description": {
      "short": "Executes continuation `body`, then pops an integer `cond` from the resulting stack. If `cond` is **zero**, performs another iteration of this loop, otherwise ends the loop.",
      "long": "The actual implementation of this primitive involves an extraordinary continuation `ec_until` with its arguments set to the `body` of the loop and the original current continuation `cc`. This extraordinary continuation is then saved into the savelist of `body` as `body.c0` and the modified `body` is then executed. The other loop primitives are implemented similarly with the aid of suitable extraordinary continuations.",
      "tags": [],
      "operands": [],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_8 100"
            },
            {
              "instruction": "PUSHCONT {\n    DEC\n    DUP"
            },
            {
              "instruction": "    EQINT 10",
              "comment": "Check if counter is ten,"
            },
            {
              "instruction": "            ",
              "comment": "if true, exit the loop"
            },
            {
              "instruction": "}"
            },
            {
              "instruction": "UNTIL",
              "comment": "Starts the loop",
              "is_main": true
            }
          ],
          "stack": {
            "input": ["Continuation", "100"],
            "output": ["10"]
          }
        }
      ],
      "docs_links": [
        {
          "name": "Save lists",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/basics-register-c0-cc-savelist-if-instruction/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "variable",
                  "var_name": "c"
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "UNTILEND": {
    "description": {
      "short": "Takes a remainder of the current continuation, executes it, then pops an integer `cond` from the resulting stack. If `cond` is **zero**, performs another iteration of this loop, otherwise ends the loop.",
      "long": "Unlike `UNTIL` which executes a separate continuation as the loop body, this instruction uses the current continuation itself as the loop body. When the loop exit condition is satisfied (when `cond` is **non-zero**), performs a `RET`.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "cc",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "cc"
                },
                "after": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "WHILE": {
    "description": {
      "short": "Executes continuation `cond`, then pops an integer `cond` from the resulting stack. If `cond` is **non-zero**, executes `body`, and then begins a new iteration, otherwise ends the loop.",
      "long": "The actual implementation of this primitive involves an extraordinary continuation `ec_while`.",
      "tags": [],
      "operands": [],
      "examples": [
        {
          "instructions": [
            {
              "instruction": "PUSHINT_4 0",
              "comment": "Initialize counter"
            },
            {
              "instruction": "PUSHCONT {\n  DUP\n  PUSHINT_4 3\n  LESS\n}",
              "comment": "Condition: check if counter < 3"
            },
            {
              "instruction": "PUSHCONT {\n  INC\n}",
              "comment": "Body: increment counter"
            },
            {
              "instruction": "WHILE",
              "comment": "Execute loop while condition is true"
            }
          ],
          "stack": {
            "input": ["0", "Condition", "Body"],
            "output": ["3"]
          }
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c'",
          "save": {
            "c0": {
              "type": "special",
              "name": "while",
              "args": {
                "cond": {
                  "type": "variable",
                  "var_name": "c'"
                },
                "body": {
                  "type": "variable",
                  "var_name": "c"
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "WHILEEND": {
    "description": {
      "short": "Executes continuation `cond`, then pops an integer `cond` from the resulting stack. If `cond` is **non-zero**, takes a remainder of the current continuation and executes it as the loop body, then begins a new iteration, otherwise ends the loop.",
      "long": "Unlike `WHILE` which executes a separate continuation `body` as the loop body, this instruction uses the current continuation itself as the loop body.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c'",
          "save": {
            "c0": {
              "type": "special",
              "name": "while",
              "args": {
                "cond": {
                  "type": "variable",
                  "var_name": "c'"
                },
                "body": {
                  "type": "cc"
                },
                "after": {
                  "type": "register",
                  "index": 0
                }
              }
            }
          }
        }
      ]
    }
  },
  "AGAIN": {
    "description": {
      "short": "Executes continuation `body` infinitely many times.",
      "long": "Unlike `REPEAT` which executes a continuation a specified number of times, this instruction creates an infinite loop. `RET` inside `body` code starts a new iteration of an infinite loop, rather than breaks from the loop. `AGAIN` loop can be exited only by an exception, `RETALT` with a `SETEXITALT` before the loop, or an explicit `JMPX`. Another way is to use `AGAINBRK`, which also sets `c1` to `cc`, and `RETALT` in the body, which will transfer control to the original `cc` and exit the loop.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "again",
          "args": {
            "body": {
              "type": "variable",
              "var_name": "c"
            }
          }
        }
      ]
    }
  },
  "AGAINEND": {
    "description": {
      "short": "Takes a remainder of the current continuation and executes it infinitely many times.",
      "long": "Unlike `AGAIN` which executes a separate continuation in an infinite loop, this instruction uses the current continuation itself as the loop body. `RET` inside `body` code starts a new iteration of an infinite loop, rather than breaks from the loop. `AGAINEND` loop can be exited only by an exception, `RETALT` with a `SETEXITALT` before the loop, or an explicit `JMPX`. Another way is to use `AGAINENDBRK`, which also sets `c1` to `cc`, and `RETALT` in the body, which will transfer control to the original `cc` and exit the loop.",
      "tags": [],
      "operands": []
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": []
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "again",
          "args": {
            "body": {
              "type": "cc"
            }
          }
        }
      ]
    }
  },
  "REPEATBRK": {
    "description": {
      "short": "Stores current continuation in `c1` of `body` and executes continuation `body` `n`-times, if integer `n` is non-negative.",
      "long": "Just like `REPEAT`, but additionally sets `c1` to the original `c` after saving the old value of `c1` into the savelist of the original `c`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before all iterations are completed.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "5",
          "condition": "If `n >= 2^31` or `n < -2^31`."
        }
      ],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "variable",
              "var_name": "c",
              "save": {
                "c1": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                }
              }
            },
            "after": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                },
                "c1": {
                  "type": "register",
                  "index": 1
                }
              }
            }
          }
        }
      ]
    }
  },
  "REPEATENDBRK": {
    "description": {
      "short": "Stores current continuation in `c1` and takes a remainder of the current continuation and executes it `n`-times, if integer `n` is non-negative.",
      "long": "Just like `REPEATEND`, but additionally sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before all iterations are completed.",
      "tags": [],
      "operands": [],
      "exit_codes": [
        {
          "errno": "5",
          "condition": "If `n >= 2^31` or `n < -2^31`."
        }
      ],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "REPEATEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "n",
            "value_types": ["Int"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "special",
          "name": "repeat",
          "args": {
            "count": "n",
            "body": {
              "type": "cc",
              "save": {
                "c1": {
                  "type": "register",
                  "index": 0
                }
              }
            },
            "after": {
              "type": "register",
              "index": 0
            }
          }
        }
      ]
    }
  },
  "UNTILBRK": {
    "description": {
      "short": "Stores current continuation in `c1` of `body` and executes continuation `body`, then pops an integer `cond` from the resulting stack. If `cond` is **zero**, performs another iteration of this loop, otherwise ends the loop.",
      "long": "Just like `UNTIL`, but additionally sets `c1` to the original continuation after saving the old value of `c1` into the savelist of the original continuation. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the exit condition is met.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "variable",
                  "var_name": "c",
                  "save": {
                    "c1": {
                      "type": "cc",
                      "save": {
                        "c0": {
                          "type": "register",
                          "index": 0
                        },
                        "c1": {
                          "type": "register",
                          "index": 1
                        }
                      }
                    }
                  }
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                }
              }
            },
            "c1": {
              "type": "cc",
              "save": {
                "c0": {
                  "type": "register",
                  "index": 0
                },
                "c1": {
                  "type": "register",
                  "index": 1
                }
              }
            }
          }
        }
      ]
    }
  },
  "UNTILENDBRK": {
    "description": {
      "short": "Stores current continuation in `c1` and takes a remainder of the current continuation, executes it, then pops an integer `cond` from the resulting stack. If `cond` is **zero**, performs another iteration of this loop, otherwise ends the loop.",
      "long": "Just like `UNTILEND`, but additionally sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the exit condition is met.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "UNTILEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "cc",
          "save": {
            "c0": {
              "type": "special",
              "name": "until",
              "args": {
                "body": {
                  "type": "cc",
                  "save": {
                    "c1": {
                      "type": "register",
                      "index": 0
                    }
                  }
                },
                "after": {
                  "type": "register",
                  "index": 0
                }
              }
            },
            "c1": {
              "type": "register",
              "index": 0
            }
          }
        }
      ]
    }
  },
  "WHILEBRK": {
    "description": {
      "short": "Stores current continuation in `c1` of `body` and executes continuation `cond`, then pops an integer `cond` from the resulting stack. If `cond` is **non-zero**, executes `body`, and then begins a new iteration, otherwise ends the loop.",
      "long": "Just like `WHILE`, but additionally sets `c1` to the original continuation after saving the old value of `c1` into the savelist of the original continuation. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the condition becomes false.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          },
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    },
    "control_flow": {
      "branches": [
        {
          "type": "variable",
          "var_name": "c'",
          "save": {
            "c0": {
              "type": "special",
              "name": "while",
              "args": {
                "cond": {
                  "type": "variable",
                  "var_name": "c'"
                },
                "body": {
                  "type": "variable",
                  "var_name": "c"
                },
                "after": {
                  "type": "cc",
                  "save": {
                    "c0": {
                      "type": "register",
                      "index": 0
                    },
                    "c1": {
                      "type": "register",
                      "index": 1
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "WHILEENDBRK": {
    "description": {
      "short": "Stores current continuation in `c1` and executes continuation `cond`, then pops an integer `cond` from the resulting stack. If `cond` is **non-zero**, takes a remainder of the current continuation and executes it as the loop body, then begins a new iteration, otherwise ends the loop.",
      "long": "Just like `WHILEEND`, but additionally sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the loop body, providing a way to exit the loop before the condition becomes false.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "WHILEEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "cond",
            "value_types": ["Continuation"]
          }
        ],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "AGAINBRK": {
    "description": {
      "short": "Store current continuation in `c1` of `body` and executes continuation `body` infinitely many times.",
      "long": "This instruction sets `c1` to the original continuation after saving the old value of `c1` into the savelist of the original continuation. This modification allows `RETALT` to be used to break out of the infinite loop, providing a way to exit the loop that would otherwise continue indefinitely.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [
          {
            "type": "simple",
            "name": "body",
            "value_types": ["Continuation"]
          }
        ]
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  },
  "AGAINENDBRK": {
    "description": {
      "short": "Stores current continuation in `c1` and takes a remainder of the current continuation and executes it infinitely many times.",
      "long": "Just like `AGAINEND`, but additionally sets `c1` to the original `c0` after saving the old value of `c1` into the savelist of the original `c0`. This modification allows `RETALT` to be used to break out of the infinite loop, providing a way to exit the loop that would otherwise continue indefinitely.",
      "tags": [],
      "operands": [],
      "docs_links": [
        {
          "name": "Exit points of continuations",
          "url": "https://txtracer.ton.org/spec/doc/book/continuations/diving-deeper-exit-points-of-continuations/"
        }
      ],
      "other_implementations": [
        {
          "exact": true,
          "instructions": ["SAMEALTSAVE", "AGAINEND"]
        }
      ]
    },
    "signature": {
      "inputs": {
        "stack": [],
        "registers": []
      },
      "outputs": {
        "stack": [],
        "registers": [
          {
            "type": "constant",
            "index": 1
          }
        ]
      }
    }
  }
}
